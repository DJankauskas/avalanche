<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Avalanche + Avalanche Web Tutorial</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">1.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="params.html"><strong aria-hidden="true">2.</strong> Data and dynamic parameters</a></li><li class="chapter-item expanded "><a href="state.html"><strong aria-hidden="true">3.</strong> Hooks, state, and control flow</a></li><li class="chapter-item expanded "><a href="reactivity.html"><strong aria-hidden="true">4.</strong> Reactivity</a></li><li class="chapter-item expanded "><a href="events.html"><strong aria-hidden="true">5.</strong> Event handling and input elements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Avalanche + Avalanche Web Tutorial</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<h2><a class="header" href="#what-is-avalanche" id="what-is-avalanche">What is avalanche?</a></h2>
<p><code>avalanche</code> is a platform-agnostic UI library aiming to bridge the strong typing, efficient runtime performance, and 
cross-platform prowess of Rust with the ergonomics of existing UI libraries like Svelte. </p>
<p>Like React and Vue, this library allows writing your UI code declaratively, with the ease-of-use of HTML
but with dynamic updates. Unlike those libraries, however, <code>avalanche</code> analyzes your code
at compile time to eliminate the need for most runtime comparisons and updates, meaning you get declarative
ergonomics with imperative performance.</p>
<p>While we believe the foundations for these goals are strong, the library is still very much a work in progress,
and the implementation may not always reach our standards yet. As such, while this library is useable for hobbyist 
projects, we <strong>DO NOT</strong> yet recommend you use this library in production.</p>
<h2><a class="header" href="#what-is-avalanche_web" id="what-is-avalanche_web">What is avalanche_web?</a></h2>
<p><code>avalanche_web</code> is the official Web platform interface for <code>avalanche</code>, allowing you to use <code>avalanche</code> in browsers and
Electron apps by compiling your app to WebAssembly. It may be missing some listeners and other functionality as of now, but all
HTML tags are available for use as components.</p>
<h2><a class="header" href="#using-this-tutorial" id="using-this-tutorial">Using this tutorial</a></h2>
<p>Before using this tutorial, you should first have a decent grasp of the Rust programming language. This tutorial also heavily uses <code>avalanche_web</code>, so you should be familiar with basic HTML.</p>
<p>This tutorial is new and still rough, so if you have any confusion or see a potential error, we'd be grateful if you
<a href="https://github.com/DJankauskas/avalanche/issues">created an issue</a>.</p>
<h2><a class="header" href="#what-are-components" id="what-are-components">What are components?</a></h2>
<p>Components are encapsulated pieces of UI, potentially with complex logic and state, that can be reused as desired. An <code>avalanche</code> app always contains a root component, and can be built out of many more.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting started</a></h1>
<h2><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h2>
<p>Before you get started, ensure you have <code>cargo</code> and <code>npm</code> installed.</p>
<h2><a class="header" href="#creating-an-app" id="creating-an-app">Creating an app</a></h2>
<p>To create an <code>avalanche_web</code> app, first run the command <code>npm init rust-webpack my-app-name</code>, where <code>my-app-name</code> is the name
of the application you wish to create. This will create a directory with name <code>my-app-name</code>. Your Rust code will live within its <code>/src</code> directory.</p>
<p>Within <code>src/lib.rs</code>, you will see some helpful preloaded setup, including a <code>panic</code> hook for debugging messages, and the <code>main_js</code> function. To get a minimal <code>avalanche_web</code> app off the ground, first we need to add some dependencies. In the <code>Cargo.toml</code> file, add the following dependencies:</p>
<pre><code class="language-toml">avalanche = { git = 'https://github.com/DJankauskas/avalanche/tree/master/avalanche' }
avalanche_web = { git = 'https://github.com/DJankauskas/avalanche/tree/master/avalanche_web` }
</code></pre>
<p>Next, add this code somewhere outside the <code>main_js</code> function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use avalanche::{component, View};
use avalanche::components::{H1, Text};

#[component]
fn HelloWorld() -&gt; View {
    H1 {
        child: Text! {text: &quot;Hello world!&quot;}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, add this call in <code>main_js</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>avalanche_web::mount_to_body::&lt;HelloWorld&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>Now, to see your app, run <code>npm start</code> within the <code>my_app_name</code> directory. If you haven't gotten any compiler errors,
you should see your first <code>avalanche</code> and <code>avalanche_web</code> web!</p>
<h2><a class="header" href="#explaining-hello-world" id="explaining-hello-world">Explaining hello world</a></h2>
<p>So what exactly is going on in the code above? Well, the most important aspect here is the <code>#[component]</code> attribute macro. 
<code>#[component]</code> accepts a function returning a <code>View</code>, which is a wrapper around an instance of a component. 
Within a function marked with <code>#[component]</code>, macros whose names begin with a capital ASCII character are interpreted as 
special component constructors. <code>Text</code> is a component with a single parameter <code>text</code>, so by specifying that we get an instance 
of <code>View</code> with that text component. <code>H1</code> can take either one <code>child</code> or an array of children, so this component here is equivalent to writing
this raw HTML:</p>
<pre><code class="language-html">&lt;h1&gt;
    Hello world!
&lt;/h1&gt;
</code></pre>
<p>Finally, we pass our new <code>HelloWorld</code> component as a type argument to <code>avalanche_web::mount_to_body</code>, which, as the name implies, 
renders our <code>HelloWorld</code> component within the <code>&lt;body&gt;&lt;/body&gt;</code> of our web app.</p>
<h1><a class="header" href="#data-and-dynamic-parameters" id="data-and-dynamic-parameters">Data and dynamic parameters</a></h1>
<h2><a class="header" href="#data" id="data">Data</a></h2>
<p>Component constructors can take expressions as parameters, not just literals:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>import avalanche::{component, View};
import avalanche::components::A;

const href: &amp;str = &quot;http://info.cern.ch/hypertext/WWW/TheProject.html&quot;;

#[component]
fn Link() -&gt; View {
    A! {
        href: href,
        child: Text! {text: &quot;The first website&quot;}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In cases where a variable has the same name as a parameter, there's a shorthand available:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>import avalanche::{component, View};
import avalanche::components::A;

const href: &amp;str = &quot;http://info.cern.ch/hypertext/WWW/TheProject.html&quot;;

#[component]
fn Link() -&gt; View {
    A! {
        // same as above
        href,
        child: Text! {text: &quot;The first website&quot;}
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#parameters-and-nesting" id="parameters-and-nesting">Parameters and nesting</a></h2>
<p>So far, we've dealt only with components with hard-coded data. However, within most practical components, we want to allow other components to pass it data.
To enable that, you simply need to add parameters to your component function. Here, let's say we want a reusable <code>Link</code> with its own custom functionality,
and want to allow a custom destination and text to be specified. We can simply just add <code>to</code> and <code>text</code> parameters:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>import avalanche::{component, View};
import avalanche::components::A;

#[component]
fn Link(to: String, text: String) -&gt; View {
    A! {
        href: to,
        child: Text! {text: text.clone()}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Notice that for the text parameter, we pass <code>text.clone()</code> instead of <code>text</code>. That's because even though we specify <code>text</code> is a <code>String</code>,
we actually receive parameters as references (allowing a componen to be rerendered when its state but not props change). So <code>text</code> is really a <code>&amp;String</code>.</p>
<p>We can then construct <code>Link</code> inside of other components:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use avalanche::{component, View};
</span><span class="boring">import avalanche::components::A;
</span><span class="boring">
</span><span class="boring">#[component]
</span><span class="boring">fn Link(to: String) -&gt; View {
</span><span class="boring">    A! {
</span><span class="boring">        href: to
</span><span class="boring">    }
</span><span class="boring">}
</span>use avalanche_web::{Text, Div};

#[component]
fn Example() -&gt; View {
    Div! {
        children: [
            Link! {
                to: &quot;https://example.com&quot;.into(),
                text: &quot;example.com&quot;.into()
            },
            Text! {text: &quot; is a domain reserved for use in demos.&quot;}
        ]
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>When rendered, the above is equivalent to the HTML below.</p>
<pre><code class="language-html">&lt;div&gt;
    &lt;a href=&quot;https://example.com&quot;&gt;
        example.com
    &lt;/a&gt;
    &amp;nbsp;is a domain reserved for use in demos.
&lt;/div&gt;
</code></pre>
<p>Within component constructors, parameter order does not matter, so we could've also written our <code>Link</code> construction with <code>to</code> and <code>text</code> swapped:</p>
<pre><code>Link! {
    text: &quot;example.com&quot;.into(),
    to: &quot;https://example.com&quot;.into()
}
</code></pre>
<h2><a class="header" href="#parameter-type-restrictions" id="parameter-type-restrictions">Parameter type restrictions</a></h2>
<p>You might have noticed that we used the <code>String</code> type for our parameters, rather than the more generic <code>&amp;str</code>. That's because 
parameters are stored and need to live longer than the function body, and are thus required to be <code>'static</code>. That means
parameter types can't contain non-<code>-static</code> references. However, <code>static</code> references like <code>&amp;'static str</code> are allowed.</p>
<h1><a class="header" href="#hooks-state-and-control-flow" id="hooks-state-and-control-flow">Hooks, State, and Control Flow</a></h1>
<h2><a class="header" href="#hooks" id="hooks">Hooks</a></h2>
<p>So far, all the data we've passed to parameters and used in general was static, specified at compilation time.
But in real apps, we usually need to maintain state for things like network request statuses and inputs.</p>
<p>Let's say we're trying to write a counter. We'll start out with a stateless counter:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use avalanche::{component, View};
use avalanche_web::components::{Div, H2, Button, Text};

#[component]
fn Counter() -&gt; View {
    Div! {
        children: [
            H2! {
                child: Text!{text: &quot;Counter!&quot;},
            },
            Button! {
                on_click: |_| todo!(),
                child: Text!{text: &quot;+&quot;}
            },
            Text! {text: 0}
        ]
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Since we don't keep track of the count yet, we've substituted it with the value <code>0</code>. <code>Text</code>'s <code>text</code> parameter accepts any value that implements <code>ToString</code>,
so we can pass <code>0</code> instead of <code>&quot;0&quot;</code>. We've also defined the <code>on_click</code> handler for <code>Button</code>, so the given closure's code will run on every click. 
Since right now we have no state to update yet, we call <code>todo!()</code>, so clicking the button would crash our app. </p>
<p>Now that we have our starting point, let's finally inject some state. The <code>UseState</code> hook allows us to inject
state so we can keep track of the number of clicks. Since we have a count that monotonically increases, we can use an unsigned integer <code>u64</code> with <code>UseState&lt;u64&gt;</code>.</p>
<p>Let's finally make or counter stateful:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use avalanche::{component, View};
</span><span class="boring">use avalanche_web::components::{Div, H2, Button, Text};
</span>
#[component(count = UseState&lt;u64&gt;)]
fn Counter() -&gt; View {
    let (count, set_count) = count(0);

    Div! {
        children: [
            H2! {
                child: Text! {text: &quot;Counter!&quot;},
            },
            Button! {
                on_click: move |_| set_counter.call(|count| *count += 1),
                child: Text! {text: &quot;+&quot;}
            },
            Text! {text: count}
        ]
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note that for examples past this point, we will be omitting <code>avalanche</code> and <code>avalanche_web</code> imports for brevity.</p>
</blockquote>
<p>First, notice that we declare hooks within the <code>#[component]</code> attribute, with the syntax <code>#[component(hook_name = HookType, ...)]</code>. For each 
<code>hook_name</code>, this introduces a variable of that name into the component function's scope. Note that each hook name must be unique within a component.</p>
<p>Here, the <code>count</code> injected by <code>UseState</code> is a function which takes the state's default value for <code>u64</code> and returns a tuple with a reference to the 
current state (which we name <code>count</code>) and a setter, which we name <code>set_count</code>. The setter has a <code>call</code> method which accepts a closure that receives a <code>&amp;mut u64</code> and modifies it. Every time the user clicks on the button, <code>on_click</code> fires, calling <code>set_counter.call()</code>, which runs 
<code>count += 1</code>, updating the state and causing the component to be rerendered. With that, we have our first stateful component! </p>
<h2><a class="header" href="#dynamic-rendering" id="dynamic-rendering">Dynamic rendering</a></h2>
<p>Oftentimes, we don't just want to update property values based on changes to state and props, but also what children we render.
In some frameworks, that requires special template syntax, but we can take advantage of the fact that the <code>Component! {}</code> syntax returns plain 
Rust values to use normal control flow instead.</p>
<h3><a class="header" href="#conditional-rendering" id="conditional-rendering">Conditional rendering</a></h3>
<p>Want to render something only if a condition is true? Use an <code>if</code> statement:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use avalanche::{component, View};
</span><span class="boring">use avalanche_web::components::Text;
</span><span class="boring">
</span>#[component]
fn Conditional(cond: bool) -&gt; View {
    if *cond {
        Text! {text: &quot;True!&quot;}
    } else {
        ().into()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>()</code> type is a <code>Component</code> that renders nothing. We call <code>.into()</code> on it to turn it into a <code>View</code>.</p>
<p>There is also a shorthand for this some component-or-nothing case:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use avalanche::{component, View};
</span><span class="boring">use avalanche_web::components::Text;
</span><span class="boring">
</span>#[component]
fn Conditional(cond: bool) -&gt; View {
    *cond.then(Text! {text: &quot;True!&quot;}).into()
}
<span class="boring">}
</span></code></pre></pre>
<p>That's equivalent to the above example. Of course, if you want more complex conditionals, you can use other control flow like <code>else if</code> and <code>match</code>.</p>
<blockquote>
<p>The <code>then</code> bool method is available in Rust versions 1.50+.</p>
</blockquote>
<h3><a class="header" href="#lists" id="lists">Lists</a></h3>
<p>We can use similar techniques to render lists of content:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use avalanche::{component, View};
</span><span class="boring">use avalanche_web::components::{Ul, Li, Text};
</span><span class="boring">
</span>#[component]
fn List(items: Vec&lt;String&gt;) -&gt; View {
    Ul! {
        children: items.iter().map(|item| Li! {
            child: Text! {text: item},
            key: item
        }).collect()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, we use the standard iterator methods <code>map</code> and <code>collect</code> to turn a <code>Vec</code> of strings into a <code>Vec</code> of <code>View</code>s.
This is mostly self-explanatory, but the important thing to note is the <code>key</code> parameter on <code>Li</code>. Whenever an instance of <code>Component!</code> in code 
may be called more than once, it is required to specify a key to disambiguate the multiple instantiations; this is enforced with a runtime error if not specified. Note that the key must be added on the topmost level, so in our example above,</p>
<pre><code>Li! {
    child: Text! {text: item},
    key: item
}
</code></pre>
<p>is good but this is not:</p>
<pre><code>Li! {
    child: Text! {
        text: item,
        key: item
    }
}
</code></pre>
<h1><a class="header" href="#reactivity" id="reactivity">Reactivity</a></h1>
<p>The previous chapter showed how even with state, we can write our UI declaratively. But how, exactly, does this work?
In theory, <code>avalanche</code> could rerender our entire app on every state change, but in practice, that's often too inefficient.
Instead, <code>avalanche</code> uses reactivity. The <code>#[component]</code> macro tracks what parameters and hook values influence the value of each 
parameter of children elements. Then, the framework updates only child parameters whose input parameters or hook values changed (although everything in 
a component function is run on rerender).</p>
<p>Usually, you won't need to worry about reactivity, but occasionally, it's helpful to know the details. As an example, let's 
say we want to show the user a random number, and update it on a button click. One potential approach could be to trigger a rerender
by calling a <code>UseState</code> setter.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use avalanche::{component, View, UseState};
</span><span class="boring">use avalanche_web::components::{Text, Div, Button};
</span>use rand::random;

#[component(trigger_update = UseState&lt;()&gt;)]
fn Random() -&gt; View {
    let (_, trigger_update) = trigger_update(());

    Div! {
        children: [
            Button! {
                child: Text! {text: &quot;Generate new number&quot;},
                on_click: move |_| trigger_update.call(|_| ())
            },
            Div! {
                child: Text! {text: random::&lt;u16&gt;()}
            } 
        ]
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>However, if you try out the example for yourself, you'll notice that the number doesn't actually update. A reasonable explanation for this would be
we're not actually modifying <code>trigger_update</code>'s state, or that its current value is equal to the previous one. However, calling a <code>UseState</code> setter <em>always</em> 
triggers a component rerender. Rather, the reason is that <code>random::&lt;u16&gt;()</code> does not depend on any state or parameters, so <code>avalanche</code> classifies the value 
as constant. To fix that, let's make the value transparently depend on state:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use avalanche::{component, View, UseState};
</span><span class="boring">use avalanche_web::components::{Text, Div, Button};
</span>use rand::random;

#[component(value = UseState&lt;u16&gt;)]
fn Random() -&gt; View {
    let (value, set_value) = value(random::&lt;u16&gt;());

    Div! {
        children: [
            Button! {
                child: Text! {text: &quot;Generate new number&quot;},
                on_click: move |_| set_value.call(|value| *value = random::&lt;u16&gt;())
            },
            Div! {
                child: Text! {text: value}
            } 
        ]
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, <code>text</code> clearly depends on the <code>value</code> state, so when we call <code>set_value</code>, <code>avalanche</code> will update that text value on screen.</p>
<p>This example leads us to the two main reactivity rules:</p>
<h3><a class="header" href="#wrap-interior-mutability-and-hidden-side-effects" id="wrap-interior-mutability-and-hidden-side-effects">Wrap interior mutability and hidden side effects</a></h3>
<p>For parameter values, directly using values like <code>rand::random()</code> is a problem because they depend on some external state
that <code>avalanche</code> is not aware of, leading to stale values displayed on rerender. This also applies to values like <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>
if they are updated outside of hook functionality. When using interior mutability, then, make sure to wrap it in <code>UseState</code>, and perform updates 
within the <code>call</code> method.</p>
<h3><a class="header" href="#avoid-third-party-macros" id="avoid-third-party-macros">Avoid third-party macros</a></h3>
<p>Macros can lead to convenient code; for example, <code>Text! {text: format!(&quot;Hello, {} {}!&quot;, rank, name)}</code> is a lot clearer than the macro-free
alternative. However, when using non-<code>std</code> and <code>avalanche</code> macros, <code>#[component]</code> is unable to track their dependencies correctly, meaning
parameters based on those macros may not update correctly. In the future, we may instead opt to consider those macros always updated (at the cost of 
efficiency). Either way, we recommend you avoid those macros. </p>
<h2><a class="header" href="#performance" id="performance">Performance</a></h2>
<p>Note that whenever a <code>UseState</code> value is considered updated, <strong>all</strong> of its subfields and method calls
are considered updated. Thus, instead of using one large state <code>struct</code>, consider breaking it apart into its constituent fields,
unless if the <code>struct</code>'s fields are usually updated all at once.</p>
<p>(More performance optimizations will become available in future library updates).</p>
<h1><a class="header" href="#event-handling-and-input-elements" id="event-handling-and-input-elements">Event handling and input elements</a></h1>
<p>So far, we've only used the <code>on_click</code> event, but there are both many more events and more functionality available.</p>
<p>In addition, many events are component-specific, like <code>on_input</code> and <code>on_blur</code> on some form elements. many of these are available,
but some have not been implemented yet. If you're missing one, please <a href="https://github.com/DJankauskas/avalanche/issues/new">file an issue!</a></p>
<h2><a class="header" href="#events" id="events">Events</a></h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers">Every global event</a> is settable as a parameter
on every non-<code>Text</code> <code>avalanche_web</code> component. Each event handling parameter takes a function of type <code>impl Fn(TypedEvent&lt;E, C&gt;)</code>
where <code>E</code> is the <code>web_sys</code> type for the handler's event type and <code>C</code> is <code>web_sys</code>'s native type for the component's native <code>web_sys</code> type.</p>
<p>Often, we don't need the event, so we omit it, hence closures like <code>on_click: move |_| ...</code>.</p>
<h2><a class="header" href="#input-elements" id="input-elements">Input elements</a></h2>
<p>One case where events are useful is with input elements. That's because the <code>TypedEvent</code> type gives access to the <code>current_target()</code> method,
which provides a reference to the component's associated native reference. We can use this to keep track of an <code>Input</code> element's state:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use avalanche::{component, View, UseState};
</span><span class="boring">use avalanche_web::components::{Input};
</span><span class="boring">
</span>#[component(text = UseState&lt;String&gt;)]
fn ControlledInput() -&gt; View {
    let (text, set_text) = text(String::new());

    Input! {
        value: Some(text.clone()),
        on_input: move |e| set_text.call(|text| *text = e.current_target().unwrap().value())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this example, <code>text</code> holds the input's current contents, allowing us to use it for other purposes.</p>
<blockquote>
<p>In React, programmers often use <code>on_change</code> instead of <code>on_input</code>, but React semantics do not match native browser ones in this case;
use <code>on_input</code> in <code>avalanche_web</code> instead.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
