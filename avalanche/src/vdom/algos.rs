use std::cell::Cell;
use std::mem::swap;
use std::num::NonZeroU64;

use rustc_hash::FxHashMap;

use crate::alloc::{Bump, CollectIn, Vec as BumpVec};
use crate::hooks::{HookContext, RenderContext, SharedContext};
use crate::renderer::{DispatchNativeEvent, NativeEvent, Scheduler};
use crate::shared::Shared;
use crate::vdom::ComponentState;
use crate::{ChildId, Component, ComponentPos, DefaultComponent, View};

use super::data::{BodyChild, CellBumpVec, ComponentId, NativeComponent, VDom, VNode};
use super::dyn_component::DynComponent;
use super::state::ComponentStateAccess;

const DYNAMIC_CHILDREN_ERR: &str = "Dynamic components must be provided keys.";

/// Renders a child of a component, given a reference to that component's `VNode` and
/// the `Component` instance describing the child. Avoids re-rendering if the child was
/// rendered before and neither its data nor the state of itself or one of its descendents
/// were updated since the last render.
/// Called within the code generated by `#[component]`. Library consumers should avoid calling this
/// themselves, as this interface is not guaranteed to be stable.
#[doc(hidden)]
pub fn render_child<'a>(component: impl Component<'a>, context: &RenderContext) -> View {
    /// A non-monomorphized implementation of the function to avoid a heavy code size penalty
    /// for every component rendered in an application.
    fn render_child<'a>(component: DynComponent, context: &RenderContext) -> View {
        // Tracks whether the component being rendered, along with its corresponding
        // native handle, was created during this call
        let mut newly_created = false;

        let (child_component_id, child_vnode_dirty, native_component_is_some, original_view) =
            context.vdom.exec_mut(|vdom| {
                let child_id = ChildId {
                    key: context.shared.key.get().map(ToOwned::to_owned),
                    location: component.location().unwrap_or_default(),
                };
                // Gets the `ComponentId` of the child if it existed previously,
                // and generates a new one otherwise.
                let body_child = vdom
                    .children
                    .get_mut(&context.body_parent_id)
                    .unwrap()
                    .body_children
                    .entry(child_id)
                    .or_insert(BodyChild {
                        id: vdom.curr_component_id.create_next(),
                        used: true,
                    });

                // Marks the child as used so its body parent will not destroy it.
                body_child.used = true;

                let child_component_id = body_child.id;
                // Gets the `VNode` associated with the `ComponentId` and removes it to
                // allow for concurrent modification of the vdom and vnode. If the vnode does not
                // exist yet, create a default value.
                let mut child_vnode =
                    vdom.children.entry(child_component_id).or_insert_with(|| {
                        newly_created = true;

                        let dispatch_native_event = DispatchNativeEvent {
                            component_id: child_component_id,
                            vdom: context.component_pos.vdom.downgrade(),
                            scheduler: context.shared.scheduler.clone(),
                        };
                        let native_component = component.is_native().then(|| {
                            let native_handle = component
                                .native_create(vdom.renderer.as_mut(), dispatch_native_event);
                            NativeComponent {
                                native_handle,
                                native_parent: None,
                                native_children: Vec::new(),
                            }
                        });
                        VNode {
                            body_parent: Some(context.component_pos.component_id),
                            body_children: FxHashMap::default(),
                            native_component,
                            state: FxHashMap::default(),
                            dirty: true,
                            view: View {
                                id: Some(child_component_id),
                                // will be overwritten in update code
                                native_component_id: None,
                            },
                        }
                    });
                child_vnode.body_parent = Some(context.component_pos.component_id);
                let native_component_is_some = child_vnode.native_component.is_some();
                (
                    child_component_id,
                    child_vnode.dirty,
                    native_component_is_some,
                    child_vnode.view.private_copy(),
                )
            });

        // If the component's props were updated or it is dirty because it was just
        // created or its state was updated, re-render the child.
        let view = if child_vnode_dirty || component.updated() {
            let native_component_id = if native_component_is_some {
                context.vdom.exec_mut(|vdom| {
                    let native_component = vdom.children[&child_component_id]
                        .native_component
                        .as_ref()
                        .unwrap();

                    // Extract current_native_event
                    let mut current_native_event = context.shared.current_native_event.take();

                    let native_event = match &current_native_event {
                        Some((_, id)) => {
                            if *id == child_component_id {
                                current_native_event.take().map(|(event, _)| event)
                            } else {
                                None
                            }
                        }
                        None => None,
                    };

                    // restore potentially modified current_native_event
                    context
                        .shared
                        .current_native_event
                        .set(current_native_event);

                    // Update only required if the component was not created during
                    // this call
                    if !newly_created {
                        component.native_update(
                            vdom.renderer.as_mut(),
                            &native_component.native_handle,
                            vdom.gen.into(),
                            native_event,
                        );
                    }

                    let new_children = component.native_children();

                    let new_native_children: BumpVec<_> = new_children
                        .iter()
                        .filter_map(|child| child.native_component_id)
                        .collect_in(context.bump);

                    let native_component = vdom
                        .children
                        .get_mut(&child_component_id)
                        .unwrap()
                        .native_component
                        .as_mut()
                        .unwrap();

                    // Extract old_native_children from native_component without preventing vdom from being
                    // mutably borrowed
                    let mut old_native_children = Vec::new();
                    std::mem::swap(
                        &mut old_native_children,
                        &mut native_component.native_children,
                    );

                    update_native_children(
                        child_component_id,
                        &mut old_native_children,
                        &new_native_children,
                        vdom,
                        context.bump,
                    );

                    let child_vnode = vdom.children.get_mut(&child_component_id).unwrap();
                    let native_component = child_vnode.native_component.as_mut().unwrap();

                    // Update children vectors by replacing them with contents of new children
                    // Note that this approach can reduce allocations by reusing the existing
                    // vector's allocation in old_native_children
                    old_native_children.clear();
                    old_native_children.extend(new_native_children);
                    native_component.native_children = old_native_children;
                });

                Some(child_component_id)
            } else {
                let mut state = ComponentState::default();
                let vdom_gen = context.vdom.exec_mut(|vdom| {
                    let child_vnode = vdom.children.get_mut(&child_component_id).unwrap();
                    // swap state out of vnode to allow passing a mut VDom reference down the stack
                    std::mem::swap(&mut state, &mut child_vnode.state);

                    // Before rendering mark all body children as unused
                    for (_, child) in child_vnode.body_children.iter_mut() {
                        child.used = false;
                    }

                    vdom.gen
                });
                // wrap state to allow joint hook creation and state consumption
                let shared_state = Shared::new(ComponentStateAccess::new(&mut state));

                let child_render_context = RenderContext {
                    vdom: context.vdom,
                    body_parent_id: child_component_id,
                    component_pos: ComponentPos {
                        component_id: child_component_id,
                        vdom: context.component_pos.vdom,
                    },
                    bump: context.bump,
                    shared: context.shared,
                };

                let child_hook_context = HookContext {
                    gen: vdom_gen.into(),
                    state: &shared_state,
                    component_pos: ComponentPos {
                        component_id: child_component_id,
                        vdom: context.component_pos.vdom,
                    },
                    bump: context.bump,
                    shared: context.shared,
                };

                // Set key to None, as within the component, it becomes a body parent
                // to its children, which shouldn't inherit the body parent's key
                let key = context.shared.key.replace(None);

                let view: View = component.render(child_render_context, child_hook_context);

                // Restore key
                context.shared.key.replace(key);

                context.vdom.exec_mut(|vdom| {
                    let child_vnode = vdom.children.get_mut(&child_component_id).unwrap();
                    // After rendering destroy all components that are body children but were not referenced in the render
                    child_vnode
                        .body_children
                        .retain(|_, BodyChild { id, used }| {
                            if !*used {
                                context.shared.components_to_remove.push(*id, context.bump);
                            };
                            *used
                        });

                    // restore the vnode's state after swapping it out earlier
                    std::mem::swap(&mut state, &mut child_vnode.state);
                });

                view.native_component_id
            };

            context.vdom.exec_mut(|vdom| {
                let child_vnode = vdom.children.get_mut(&child_component_id).unwrap();

                child_vnode.view.native_component_id = native_component_id;
                child_vnode.dirty = false;
                child_vnode.view.private_copy()
            })
        } else {
            original_view
        };
        view
    }

    // Call the type-erased implementation of the function
    render_child(
        DynComponent::new_in(component, context.vdom.exec(|vdom| vdom.gen), &context.bump),
        context,
    )
}

/// Takes old and new native children, as component ids of native components.
/// `old_native_children` must be a superset of the native children of `parent_handle`.
/// Updates the native children of `parent_handle` such that its native children correspond
/// with the native components of each child in `new_native_child` in order.
pub(super) fn update_native_children(
    parent_id: ComponentId,
    old_native_children: &mut Vec<ComponentId>,
    new_native_children: &[ComponentId],
    vdom: &mut VDom,
    bump: &Bump,
) {
    let parent_native_component = vdom.children[&parent_id].native_component.as_ref().unwrap();
    let parent_handle = &parent_native_component.native_handle;

    // Fast path for component being completely cleared of children
    if new_native_children.is_empty() {
        if !old_native_children.is_empty() {
            vdom.renderer.truncate_children(parent_handle, 0);
        }
        return;
    }

    // TODO: implement better diffing algorithm.

    // Filter out components from old_native_children that have been reparented elsewhere, and thus are no longer
    // present within the given `parent_handle`
    old_native_children.retain(|child| {
        vdom.children[child]
            .native_component
            .as_ref()
            .unwrap()
            .native_parent
            == Some(parent_id)
    });
    let mut old_native_children_map = FxHashMap::default();
    old_native_children_map.reserve(std::cmp::max(
        old_native_children.len(),
        new_native_children.len(),
    ));
    for (i, child) in old_native_children.iter().enumerate() {
        old_native_children_map.insert(*child, (i, *child));
    }

    if old_native_children.len() != old_native_children_map.len() {
        panic!("{}", DYNAMIC_CHILDREN_ERR);
    }

    let mut set_native_parent = BumpVec::new_in(bump);

    for (i, new_child) in new_native_children.iter().enumerate() {
        let (j, _) = old_native_children_map
            .entry(*new_child)
            .or_insert_with(|| {
                let new_native_component =
                    vdom.children[new_child].native_component.as_ref().unwrap();
                if new_native_component.native_parent != Some(parent_id) {
                    set_native_parent.push(*new_child);
                }
                vdom.renderer
                    .append_child(parent_handle, &new_native_component.native_handle);
                let i = old_native_children.len();
                old_native_children.push(*new_child);
                (i, *new_child)
            });
        let j = *j;
        if i != j {
            vdom.renderer.swap_children(parent_handle, i, j);
            let swap_child = old_native_children[i];
            old_native_children_map.get_mut(&swap_child).unwrap().0 = j;
            old_native_children.swap(i, j);
        }
    }

    if new_native_children.len() < old_native_children.len() {
        vdom.renderer
            .truncate_children(parent_handle, new_native_children.len());
    }

    for native_id in set_native_parent {
        vdom.children
            .get_mut(&native_id)
            .unwrap()
            .native_component
            .as_mut()
            .unwrap()
            .native_parent = Some(parent_id);
    }
}

pub(super) fn render_vdom<'a, C: DefaultComponent>(
    vdom: &mut VDom,
    shared_vdom: &Shared<VDom>,
    scheduler: &Shared<dyn Scheduler>,
    current_native_event: Option<(NativeEvent, ComponentId)>,
) {
    // Extract bump from vdom so it can be borrowed without preventing vdom from being mutably borrowed
    let mut bump = Bump::new();
    swap(&mut vdom.bump, &mut bump);

    let components_to_remove = CellBumpVec::new_in(&bump);

    let shared_context = SharedContext {
        scheduler,
        current_native_event: &Cell::new(current_native_event),
        components_to_remove: &components_to_remove,
        key: &Cell::new(None),
    };

    render_child(
        C::new(&bump),
        &RenderContext {
            vdom: &Shared::new(vdom),
            body_parent_id: ComponentId::new(),
            component_pos: ComponentPos {
                component_id: ComponentId::new(),
                vdom: shared_vdom,
            },
            bump: &bump,
            shared: &shared_context,
        },
    );

    // TODO: code duplicated from render_child; factor out into function?
    let vnode = vdom.children.get_mut(&ComponentId::new()).unwrap();
    let native_component = vnode.native_component.as_mut().unwrap();

    // Extract old_native_children from native_component so it can be mutably borrowed without preventing vdom from being mutably borrowed
    let mut old_native_children = Vec::new();
    swap(
        &mut native_component.native_children,
        &mut old_native_children,
    );

    let new_native_children: BumpVec<_> = vdom.children[&ComponentId {
        id: NonZeroU64::new(2).unwrap(),
    }]
        .view
        .native_component_id
        .iter()
        .cloned()
        .collect_in(&bump);

    update_native_children(
        ComponentId::new(),
        &mut old_native_children,
        &new_native_children,
        vdom,
        &bump,
    );

    // Remove the vnodes marked for deletion
    vdom.remove_node(components_to_remove.into_inner());

    let vnode = vdom.children.get_mut(&ComponentId::new()).unwrap();
    let native_component = vnode.native_component.as_mut().unwrap();

    old_native_children.clear();
    old_native_children.extend(new_native_children);

    // Restore old_native_children to native_component, now with new children in the Vec instead
    native_component.native_children = old_native_children;

    vdom.gen.inc();

    // Reset bump allocations, then restore allocator to vdom
    bump.reset();
    swap(&mut vdom.bump, &mut bump);
}
